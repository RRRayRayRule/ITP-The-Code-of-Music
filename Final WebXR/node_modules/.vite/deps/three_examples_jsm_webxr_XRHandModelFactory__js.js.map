{
  "version": 3,
  "sources": ["../../three/examples/jsm/webxr/XRHandPrimitiveModel.js", "../../three/examples/jsm/webxr/XRHandMeshModel.js", "../../three/examples/jsm/webxr/XRHandModelFactory.js"],
  "sourcesContent": ["import {\n\tDynamicDrawUsage,\n\tSphereGeometry,\n\tBoxGeometry,\n\tMeshStandardMaterial,\n\tInstancedMesh,\n\tMatrix4,\n\tVector3\n} from 'three';\n\nconst _matrix = new Matrix4();\nconst _vector = new Vector3();\n\n/**\n * Represents one of the hand model types {@link XRHandModelFactory} might produce\n * depending on the selected profile. `XRHandPrimitiveModel` represents a hand\n * with sphere or box primitives according to the selected `primitive` option.\n *\n * @three_import import { XRHandPrimitiveModel } from 'three/addons/webxr/XRHandPrimitiveModel.js';\n */\nclass XRHandPrimitiveModel {\n\n\t/**\n\t * Constructs a new XR hand primitive model.\n\t *\n\t * @param {XRHandModel} handModel - The hand model.\n\t * @param {Group} controller - The WebXR controller.\n\t * @param {string} path - The model path.\n\t * @param {XRHandedness} handedness - The handedness of the XR input source.\n\t * @param {XRHandPrimitiveModel~Options} options - The model options.\n\t */\n\tconstructor( handModel, controller, path, handedness, options ) {\n\n\t\t/**\n\t\t * The WebXR controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t/**\n\t\t * The hand model.\n\t\t *\n\t\t * @type {XRHandModel}\n\t\t */\n\t\tthis.handModel = handModel;\n\n\t\t/**\n\t\t * The model's environment map.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.envMap = null;\n\n\t\tlet geometry;\n\n\t\tif ( ! options || ! options.primitive || options.primitive === 'sphere' ) {\n\n\t\t\tgeometry = new SphereGeometry( 1, 10, 10 );\n\n\t\t} else if ( options.primitive === 'box' ) {\n\n\t\t\tgeometry = new BoxGeometry( 1, 1, 1 );\n\n\t\t}\n\n\t\tconst material = new MeshStandardMaterial();\n\n\t\tthis.handMesh = new InstancedMesh( geometry, material, 30 );\n\t\tthis.handMesh.frustumCulled = false;\n\t\tthis.handMesh.instanceMatrix.setUsage( DynamicDrawUsage ); // will be updated every frame\n\t\tthis.handMesh.castShadow = true;\n\t\tthis.handMesh.receiveShadow = true;\n\t\tthis.handModel.add( this.handMesh );\n\n\t\tthis.joints = [\n\t\t\t'wrist',\n\t\t\t'thumb-metacarpal',\n\t\t\t'thumb-phalanx-proximal',\n\t\t\t'thumb-phalanx-distal',\n\t\t\t'thumb-tip',\n\t\t\t'index-finger-metacarpal',\n\t\t\t'index-finger-phalanx-proximal',\n\t\t\t'index-finger-phalanx-intermediate',\n\t\t\t'index-finger-phalanx-distal',\n\t\t\t'index-finger-tip',\n\t\t\t'middle-finger-metacarpal',\n\t\t\t'middle-finger-phalanx-proximal',\n\t\t\t'middle-finger-phalanx-intermediate',\n\t\t\t'middle-finger-phalanx-distal',\n\t\t\t'middle-finger-tip',\n\t\t\t'ring-finger-metacarpal',\n\t\t\t'ring-finger-phalanx-proximal',\n\t\t\t'ring-finger-phalanx-intermediate',\n\t\t\t'ring-finger-phalanx-distal',\n\t\t\t'ring-finger-tip',\n\t\t\t'pinky-finger-metacarpal',\n\t\t\t'pinky-finger-phalanx-proximal',\n\t\t\t'pinky-finger-phalanx-intermediate',\n\t\t\t'pinky-finger-phalanx-distal',\n\t\t\t'pinky-finger-tip'\n\t\t];\n\n\t}\n\n\t/**\n\t * Updates the mesh based on the tracked XR joints data.\n\t */\n\tupdateMesh() {\n\n\t\tconst defaultRadius = 0.008;\n\t\tconst joints = this.controller.joints;\n\n\t\tlet count = 0;\n\n\t\tfor ( let i = 0; i < this.joints.length; i ++ ) {\n\n\t\t\tconst joint = joints[ this.joints[ i ] ];\n\n\t\t\tif ( joint.visible ) {\n\n\t\t\t\t_vector.setScalar( joint.jointRadius || defaultRadius );\n\t\t\t\t_matrix.compose( joint.position, joint.quaternion, _vector );\n\t\t\t\tthis.handMesh.setMatrixAt( i, _matrix );\n\n\t\t\t\tcount ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.handMesh.count = count;\n\t\tthis.handMesh.instanceMatrix.needsUpdate = true;\n\n\t}\n\n}\n\n/**\n * Constructor options of `XRHandPrimitiveModel`.\n *\n * @typedef {Object} XRHandPrimitiveModel~Options\n * @property {('box'|'sphere')} [primitive] - The primitive type.\n **/\n\nexport { XRHandPrimitiveModel };\n", "import { GLTFLoader } from '../loaders/GLTFLoader.js';\n\nconst DEFAULT_HAND_PROFILE_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/';\n\n/**\n * Represents one of the hand model types {@link XRHandModelFactory} might produce\n * depending on the selected profile. `XRHandMeshModel` represents a hand with a\n * custom asset.\n *\n * @three_import import { XRHandMeshModel } from 'three/addons/webxr/XRHandMeshModel.js';\n */\nclass XRHandMeshModel {\n\n\t/**\n\t * Constructs a new XR hand mesh model.\n\t *\n\t * @param {XRHandModel} handModel - The hand model.\n\t * @param {Group} controller - The WebXR controller.\n\t * @param {?string} path - The model path.\n\t * @param {XRHandedness} handedness - The handedness of the XR input source.\n\t * @param {?Loader} [loader=null] - The loader. If not provided, an instance of `GLTFLoader` will be used to load models.\n\t * @param {?Function} [onLoad=null] - A callback that is executed when a controller model has been loaded.\n\t */\n\tconstructor( handModel, controller, path, handedness, loader = null, onLoad = null ) {\n\n\t\t/**\n\t\t * The WebXR controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t/**\n\t\t * The hand model.\n\t\t *\n\t\t * @type {XRHandModel}\n\t\t */\n\t\tthis.handModel = handModel;\n\n\t\t/**\n\t\t * An array of bones representing the bones\n\t\t * of the hand skeleton.\n\t\t *\n\t\t * @type {Array<Bone>}\n\t\t */\n\t\tthis.bones = [];\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new GLTFLoader();\n\t\t\tloader.setPath( path || DEFAULT_HAND_PROFILE_PATH );\n\n\t\t}\n\n\t\tloader.load( `${handedness}.glb`, gltf => {\n\n\t\t\tconst object = gltf.scene.children[ 0 ];\n\t\t\tthis.handModel.add( object );\n\n\t\t\tconst mesh = object.getObjectByProperty( 'type', 'SkinnedMesh' );\n\t\t\tmesh.frustumCulled = false;\n\t\t\tmesh.castShadow = true;\n\t\t\tmesh.receiveShadow = true;\n\n\t\t\tconst joints = [\n\t\t\t\t'wrist',\n\t\t\t\t'thumb-metacarpal',\n\t\t\t\t'thumb-phalanx-proximal',\n\t\t\t\t'thumb-phalanx-distal',\n\t\t\t\t'thumb-tip',\n\t\t\t\t'index-finger-metacarpal',\n\t\t\t\t'index-finger-phalanx-proximal',\n\t\t\t\t'index-finger-phalanx-intermediate',\n\t\t\t\t'index-finger-phalanx-distal',\n\t\t\t\t'index-finger-tip',\n\t\t\t\t'middle-finger-metacarpal',\n\t\t\t\t'middle-finger-phalanx-proximal',\n\t\t\t\t'middle-finger-phalanx-intermediate',\n\t\t\t\t'middle-finger-phalanx-distal',\n\t\t\t\t'middle-finger-tip',\n\t\t\t\t'ring-finger-metacarpal',\n\t\t\t\t'ring-finger-phalanx-proximal',\n\t\t\t\t'ring-finger-phalanx-intermediate',\n\t\t\t\t'ring-finger-phalanx-distal',\n\t\t\t\t'ring-finger-tip',\n\t\t\t\t'pinky-finger-metacarpal',\n\t\t\t\t'pinky-finger-phalanx-proximal',\n\t\t\t\t'pinky-finger-phalanx-intermediate',\n\t\t\t\t'pinky-finger-phalanx-distal',\n\t\t\t\t'pinky-finger-tip',\n\t\t\t];\n\n\t\t\tjoints.forEach( jointName => {\n\n\t\t\t\tconst bone = object.getObjectByName( jointName );\n\n\t\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\t\tbone.jointName = jointName;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( `Couldn't find ${jointName} in ${handedness} hand mesh` );\n\n\t\t\t\t}\n\n\t\t\t\tthis.bones.push( bone );\n\n\t\t\t} );\n\n\t\t\tif ( onLoad ) onLoad( object );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Updates the mesh based on the tracked XR joints data.\n\t */\n\tupdateMesh() {\n\n\t\t// XR Joints\n\t\tconst XRJoints = this.controller.joints;\n\n\t\tfor ( let i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tconst XRJoint = XRJoints[ bone.jointName ];\n\n\t\t\t\tif ( XRJoint.visible ) {\n\n\t\t\t\t\tconst position = XRJoint.position;\n\n\t\t\t\t\tbone.position.copy( position );\n\t\t\t\t\tbone.quaternion.copy( XRJoint.quaternion );\n\t\t\t\t\t// bone.scale.setScalar( XRJoint.jointRadius || defaultRadius );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { XRHandMeshModel };\n", "import {\n\tObject3D\n} from 'three';\n\nimport {\n\tXRHandPrimitiveModel\n} from './XRHandPrimitiveModel.js';\n\nimport {\n\tXRHandMeshModel\n} from './XRHandMeshModel.js';\n\n/**\n * Represents a XR hand model.\n *\n * @augments Object3D\n */\nclass XRHandModel extends Object3D {\n\n\t/**\n\t * Constructs a new XR hand model.\n\t *\n\t * @param {Group} controller - The hand controller.\n\t */\n\tconstructor( controller ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The hand controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t/**\n\t\t * The motion controller.\n\t\t *\n\t\t * @type {?MotionController}\n\t\t * @default null\n\t\t */\n\t\tthis.motionController = null;\n\n\t\t/**\n\t\t * The controller's environment map.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.envMap = null;\n\n\t\t/**\n\t\t * The model mesh.\n\t\t *\n\t\t * @type {Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.mesh = null;\n\n\t}\n\n\t/**\n\t * Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.motionController ) {\n\n\t\t\tthis.motionController.updateMesh();\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Similar to {@link XRControllerModelFactory}, this class allows to create hand models\n * for WebXR controllers that can be added as a visual representation to your scene.\n *\n * ```js\n * const handModelFactory = new XRHandModelFactory();\n *\n * const hand = renderer.xr.getHand( 0 );\n * hand.add( handModelFactory.createHandModel( hand ) );\n * scene.add( hand );\n * ```\n *\n * @three_import import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';\n */\nclass XRHandModelFactory {\n\n\t/**\n\t * Constructs a new XR hand model factory.\n\t *\n\t * @param {?GLTFLoader} [gltfLoader=null] - A glTF loader that is used to load hand models.\n\t * @param {?Function} [onLoad=null] - A callback that is executed when a hand model has been loaded.\n\t */\n\tconstructor( gltfLoader = null, onLoad = null ) {\n\n\t\t/**\n\t\t * A glTF loader that is used to load hand models.\n\t\t *\n\t\t * @type {?GLTFLoader}\n\t\t * @default null\n\t\t */\n\t\tthis.gltfLoader = gltfLoader;\n\n\t\t/**\n\t\t * The path to the model repository.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.path = null;\n\n\t\t/**\n\t\t * A callback that is executed when a hand model has been loaded.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.onLoad = onLoad;\n\n\t}\n\n\t/**\n\t * Sets the path to the hand model repository.\n\t *\n\t * @param {string} path - The path to set.\n\t * @return {XRHandModelFactory} A reference to this instance.\n\t */\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a controller model for the given WebXR hand controller.\n\t *\n\t * @param {Group} controller - The hand controller.\n\t * @param {('spheres'|'boxes'|'mesh')} [profile] - The model profile that defines the model type.\n\t * @return {XRHandModel} The XR hand model.\n\t */\n\tcreateHandModel( controller, profile ) {\n\n\t\tconst handModel = new XRHandModel( controller );\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.hand && ! handModel.motionController ) {\n\n\t\t\t\thandModel.xrInputSource = xrInputSource;\n\n\t\t\t\t// @todo Detect profile if not provided\n\t\t\t\tif ( profile === undefined || profile === 'spheres' ) {\n\n\t\t\t\t\thandModel.motionController = new XRHandPrimitiveModel( handModel, controller, this.path, xrInputSource.handedness, { primitive: 'sphere' } );\n\n\t\t\t\t} else if ( profile === 'boxes' ) {\n\n\t\t\t\t\thandModel.motionController = new XRHandPrimitiveModel( handModel, controller, this.path, xrInputSource.handedness, { primitive: 'box' } );\n\n\t\t\t\t} else if ( profile === 'mesh' ) {\n\n\t\t\t\t\thandModel.motionController = new XRHandMeshModel( handModel, controller, this.path, xrInputSource.handedness, this.gltfLoader, this.onLoad );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcontroller.visible = true;\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tcontroller.visible = false;\n\t\t\t// handModel.motionController = null;\n\t\t\t// handModel.remove( scene );\n\t\t\t// scene = null;\n\n\t\t} );\n\n\t\treturn handModel;\n\n\t}\n\n}\n\nexport { XRHandModelFactory };\n"],
  "mappings": "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",
  "names": []
}
